---
layout: post
title:  비트 벡터(Bit Vector) 이용하기
tags:   ['Algorithm']
---

> 비트 벡터를 이용하면 메모리 사용을 크게 줄일 수 있습니다. 예제를 통해 비트 벡터를 어떻게 사용하는지와 어떤 장점이 있는지를 알아봅시다.  

<br/>  

## 비트 벡터란  

### 비트 연산자  

비트 벡터를 구현하기 위해서는 비트 연산자를 다룰 줄 알아야 합니다. 간단히 살펴봅시다.  

#### `<<` left shift 연산자  
연산자 왼쪽에 위치한 비트 값에 대해 연산자 오른쪽에 위치한 수 만큼 왼쪽으로 이동 시킵니다.  
```
1 << 4
```  


```
0000 0001

0001 0000
```   

연산 과정은 위와 같고 결과 값은 16이 됩니다.  

<br/>  

#### `>>` right shift 연산자  
반대로 right shift 연산자는 오른쪽으로 이동시킵니다.  

```
5 << 4
```  

```
0010 0000

0000 0010
```   

연산 과정은 위와 같고 결과 값은 2이 됩니다.  

<br/>  

#### `|` OR 연산  

```
0 | 0  ->  0
1 | 0  ->  1
0 | 1  ->  1
1 | 1  ->  1
```  

OR 연산은 특정 비트값을 1으로 만들고 싶을 때 사용할 수 있습니다. 바꾸고자 하는 값에 원하는 비트 위치에 1, 나머지는 0으로 채운 값으로 OR 연산을 하면 됩니다.  
예를 들어 `0000 0001`를 `0001 1001` 로 바꾸고 싶다면 `0000 0001`에 4,5번 째 값을 1로 바꾸고 싶은 것이므로 `0001 1000` 과 OR 연산을 해주면 됩니다.  

```
0000 0001 | 0001 1000  ->  0001 1001
1 | 24 = 25
```    

<br/>  

#### `&` AND 연산  

```
0 & 0  ->  0
1 & 0  ->  0
0 & 1  ->  0
1 & 1  ->  1
```  

AND 연산은 OR 연산과 같은 방식으로 특정 비트값을 0으로 만들고 싶을 때 사용할 수 있습니다.   

그리고 특정 비트가 1인지 확인할 수 있습니다. 원하는 위치에는 1, 나머지는 0으로 채운 값으로 AND 연산을 하면 됩니다.   

```
0001 & 0100  ->  0000
0101 & 0100  ->  0100

1 & 4 = 0
5 & 4 = 4
```   

즉, 확인하고자 하는 위치의 비트값이 0이면 결과는 0이 되고, 1이면 위의 예제에서 두번 째 결과 4와 같이 확인하고자 하는 비트 위치의 값이 그대로 출력됩니다.  

<br/>   

## 예제  

a부터 z까지의 문자로만 구성된 문자열이 주어질 때, 해당 문자열에 대해 중복되는 문자가 있는지 없는지를 판단하는 코드를 작성해보려고 합니다. 단순히 생각해보면, 문자열 내의 각 문자에 대해 나머지 다른 문자들과 비교해서 같은 값이 하나라도 있으면 '중복 있음', 반복문을 모두 통과하면 '중복 없음' 으로 간단하게 해결할 수 있을 것입니다. 하지만 이렇게 작성한 코드의 시간 복잡도는 문자열의 각각의 문자에 대해 나머지 다른 문자들도 모두 검사해야하므로 O(N²)이 됩니다. (N은 문자열의 길이 입니다.)    

a부터 z까지의 문자로만 구성된다는 특징을 잘 이용하면 메모리를 조금 사용하기는 하지만 시간적 측면에서는 더 개선시킬 수 있습니다. a부터 z까지의 문자는 총 26개. 26 크기의 배열을 이용하여 해당 문자의 사용 여부를 표시하는 것입니다.  

```java
boolean isUniqueChars(String str) {
    boolean[] alphabet_set = new boolean[26];
    for (int i = 0; i < str.length(); i++) {
        int val = str.charAt(i) - 'a';
        if (alphabet_set[val])
            return false;
        alphabet_set[val] = true;
    }
    return true;
}
```  

이렇게 하면 시간 복잡도를 O(N)으로 줄일 수 있습니다. 26이라는 추가적인 공간을 사용하지만 상수이므로 공간 복잡도는 O(1)이 됩니다.  

비트 벡터를 이용하면 어떻게 될까요? 위의 코드에서 `alphabet_set` 의 boolean 26개의 메모리 대신에 int형 변수 하나로 처리가 가능해집니다.  

```java
boolean isUniqueChars(String str) {
    int checker = 0;
    for (int i = 0; i < str.length(); i++) {
        int val = str.charAt(i) - 'a';
        if ((checker & (1 << val)) > 0)
            return false;
        checker |= (1 << val);
    }
    return true;
}
```   

if문 에서는 1 에 대해 val 만큼 시프트 연산을 하고 checker 와 & 연산으로 해당 값이 이전에 나왔었는지 검사합니다.
or연산으로 checker에 방금 나온 문자를 업데이트 합니다.  



위의 예제에서는 설명을 위해 간단한 코드를 사용하여 성능 차이가 별로 없지만 상황에 따라서 잘 사용하면 메모리의 효율을 크게 증가시킬 수 있습니다.  
